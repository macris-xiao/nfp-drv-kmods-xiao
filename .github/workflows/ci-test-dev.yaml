name: Driver Regression Tests
run-name: >-
  Driver Regressions: ${{ inputs.test }}-${{ inputs.fw_type }}

on:
  workflow_dispatch:
    secrets:
      GHUB_TOKEN:
        required: true
      AZ_SAS_TOK:
        required: true
    inputs:
      test:
        type: string
        required: true
        default: 'all'
        description: >-
          Specify which test/s to run
      fw_type:
        type: choice
        required: false
        options:
          - AUTO:all
          - BPF:agilio-bpf-firmware
          - NIC:agilio-nic-firmware
          - SRIOV:agilio-sriov-firmware
          - DISA:agilio-flower-app-firmware
        description: >-
          Specify which type of firmware to use
          when running the specified tests
      fw_version:
        type: string
        required: false
        default: ''
        description: >-
          Name/Version of firmware to use
          when running the specified tests, e.g. Specifying
          "22.07-0" in combination with `fw_type=NIC:agilio-nic-firmware`
          will result in "agilio-nic-firmware-22.07-0.tar.gz" being used.
          If left blank, the latest version of that firmware type will be used.
      fw_release_type:
        type: choice
        required: false
        options:
          - releases
          - prereleases
          - interim
          - temporary
        description: >-
          Release type of the firmware to use
          when running the specified tests
      kernel:
        type: string
        default: ''
        required: false
        description: >-
          Which kernel to install on the DUT, if blank the latest build
          available will be used
      kernel_source:
        type: choice
        required: true
        options:
          - linux_stable
          - linux_net_next
        description: >-
          Which flavour of kernel to use
      platform:
        type: choice
        required: true
        options:
          - osprey
          - kestrel
          - all
        description: >-
          NFP architecture on which to run tests
      os:
        type: choice
        required: false
        options:
          - any
          - CentOS-8
          - Ubuntu-20.04
          - all
        description: >-
          Which operating system the cluster DUT should be
          running.
      base_branch:
        description: >-
          Override default branch definition. This refers to the branch
          that the testing branch is based on. Only requires changing if
          branch being tested is a part of a specific project. E.g. if
          the changes in the branch being tested are a part of a project
          to provide a specific feature for client01, which has its own branch,
          wip-client01, one should specify wip-client01 as the base branch.
        type: string
        required: true
        default: 'main'
jobs:
  # ===================================================
  # PREPARE - derive test parameters, determine workflow skipping
  prepare:
    name: 'Prepare'
    runs-on:
      - self-hosted
      - ci-linter-vm
    outputs:
      matrix: ${{ steps.matrix.outputs.matrix }}
    steps:

      - name: User inputs
        shell: python3 {0}
        run: |
          import json
          inputs ={ "test" : "${{ inputs.test }}",
                    "fw_type" : "${{ inputs.fw_type }}",
                    "fw_version" : "${{ inputs.fw_version }}",
                    "fw_release_type" : "${{ inputs.fw_release_type }}",
                    "kernel" : "${{ inputs.kernel }}",
                    "kernel_source" : "${{ inputs.kernel_source }}",
                    "platform" : "${{ inputs.platform }}",
                    "os" : "${{ inputs.os }}",
                    "base_branch" : "${{ inputs.base_branch }}"
                    }
          print(json.dumps(inputs, indent=1))

      - name: Fail if test specified but not fw_type
        if: inputs.test != 'all' && inputs.fw_type == 'AUTO:all'
        run: |
          echo "::error::Test specified but not firmware type"
          exit 1

      - name: Checkout provisioning repo
        uses: actions/checkout@v3
        with:
          repository: Corigine/ci-libs
          ref: main
          token: ${{ secrets.GHUB_TOKEN }}
          path: ci-libs

      - name: Extract Ticket name from branch
        shell: bash
        run: |
          HEAD_REF="${{ github.head_ref || github.ref_name }}"
          echo "JIRA_TICKET=$(echo $HEAD_REF | grep -Eo '[A-Za-z]+[^[:alnum:]]?[0-9]+' | head -1 || true)" >> $GITHUB_ENV

      - name: Get available kernels - CentOS-8
        uses: ./ci-libs/github_actions/azure/azcopy_list
        id: artifact-centos
        with:
          connection-string: ${{ secrets.AZ_SAS_TOK }}
          src: tmp/misc/kernels/${{ inputs.kernel_source }}_builds/CentOS-8/
          pattern: '.*'

      - name: Get available kernels - Ubuntu-20.04
        uses: ./ci-libs/github_actions/azure/azcopy_list
        id: artifact-ubuntu
        with:
          connection-string: ${{ secrets.AZ_SAS_TOK }}
          src: tmp/misc/kernels/${{ inputs.kernel_source }}_builds/Ubuntu-20.04/
          pattern: '.*'

      - name: Set kernel to use
        shell: bash
        run: |
          FILES_CENTOS=$(echo "${{ steps.artifact-centos.outputs.file-list }}" | sed -E 's/^[a-zA-Z ]*kernel/kernel/')
          FILES_UBUNTU=$(echo "${{ steps.artifact-ubuntu.outputs.file-list }}" | sed -E 's/^[a-zA-Z ]*kernel/kernel/')
          if [[ '${{ github.event_name }}' = 'workflow_dispatch' ]]; then
            if [[ '${{ inputs.kernel }}' = '' ]]; then
              # No kernel specified, use the latest available
              if [[ '${{ inputs.os }}' = 'all' || '${{ inputs.os }}' = 'any' ]]; then
              # Need to select the latest kernel that is available for both operating systems
                KERNEL_TAR=
                NUM_CENTOS=$(echo $FILES_CENTOS | awk --field-separator=" " "{ print NF }")
                NUM_UBUNTU=$(echo $FILES_UBUNTU | awk --field-separator=" " "{ print NF }")
                for i in $(seq $NUM_CENTOS -1 1); do
                  CENTOS_KERNEL=$(echo $FILES_CENTOS | awk -v index_var=$i '{ print $index_var }')
                  for j in $(seq $NUM_UBUNTU -1 1); do
                    UBUNTU_KERNEL=$(echo $FILES_UBUNTU | awk -v index_var=$j '{ print $index_var }')
                    if [[ $CENTOS_KERNEL = $UBUNTU_KERNEL ]]; then
                      KERNEL_TAR=$CENTOS_KERNEL
                      break
                    fi
                  done
                  if [[ $KERNEL_TAR != '' ]]; then
                    break
                  fi
                done
                if [[ $KERNEL_TAR = '' ]]; then
                # No kernel is found that is available for both CentOS and Ubuntu
                  echo "::notice::No appropriate kernel found"
                  exit 2
                else
                  echo "KERNEL_TAR=$KERNEL_TAR" >> $GITHUB_ENV
                  echo "::notice::Kernel $KERNEL_TAR will be used"
                fi
              else
                if [[ '${{ inputs.os }}' == 'CentOS-8' ]]; then
                  echo "KERNEL_TAR=$(echo $FILES_CENTOS | awk '{ print $1 }')" >> $GITHUB_ENV
                  echo "::notice::Kernel $(echo $FILES_CENTOS | awk '{ print $1 }') will be used"
                else
                  echo "KERNEL_TAR=$(echo $FILES_UBUNTU | awk '{ print $1 }')" >> $GITHUB_ENV
                  echo "::notice::Kernel $(echo $FILES_UBUNTU | awk '{ print $1 }') will be used"
                fi
              fi
            else
              KERNEL_TAR="$(echo ${FILES_CENTOS} | grep -Eo '[^ ]*${{ inputs.kernel }}[^ ]*' || true)"
              if [[ -z $KERNEL_TAR ]]; then
                # Specified kernel is not found
                echo "::notice::Kernel '' not found"
                exit 2
              else
                echo "KERNEL_TAR=$KERNEL_TAR" >> $GITHUB_ENV
                echo "::notice::Kernel ${KERNEL_TAR} will be used"
              fi
            fi
          else
            KERNEL_TAR="$(echo ${FILES} | grep -Eo '[^ ]*${{ env.JIRA_TICKET }}[^ ]*' || true)"
            if [[ -z $KERNEL_TAR ]]; then
              # Kernel corresponding to Jira ticket not found, use latest available
              echo "KERNEL_TAR=$(echo $FILES | awk '{ print $1 }')" >> $GITHUB_ENV
              echo "::notice::Kernel $(echo $FILES | awk '{ print $1 }') will be used"
            else
              echo "KERNEL_TAR=$KERNEL_TAR" >> $GITHUB_ENV
              echo "::notice::Kernel ${KERNEL_TAR} will be used"
            fi
          fi

      - name: Set firmware search key
        shell: bash
        run: |
          if [ "$FW_TYPE" = 'AUTO:all' ]; then
            echo "SEARCH_KEY=" >> $GITHUB_ENV
          else
            echo "SEARCH_KEY=${FW_TYPE#*:}-.*$FW_VER.*" >> $GITHUB_ENV
          fi
        env:
          FW_TYPE: ${{ inputs.fw_type }}
          FW_VER: ${{ inputs.fw_version }}

      - name: Set firmware path
        if: github.event_name != 'push'
        shell: bash
        run: |
          if [ "$RELEASE" = "releases" ] || [ "$RELEASE" = "prereleases" ]; then
            echo "BPF_FW_PATH=binaries/nic/bpf/tgz" >> $GITHUB_ENV
            echo "DISA_FW_PATH=binaries/disa/$RELEASE/tgz" >> $GITHUB_ENV
            echo "NIC_FW_PATH=binaries/nic/$RELEASE/tgz" >> $GITHUB_ENV
          elif [ "$RELEASE" = "interim" ]; then
            echo "BPF_FW_PATH=binaries/nic/bpf/tgz" >> $GITHUB_ENV
            echo "DISA_FW_PATH=binaries/disa/$RELEASE/agilio-tc-firmware/tgz" >> $GITHUB_ENV
            echo "NIC_FW_PATH=binaries/nic/$RELEASE/tgz" >> $GITHUB_ENV
          else
            echo "BPF_FW_PATH=tmp/bpf_builds/tgz" >> $GITHUB_ENV
            echo "DISA_FW_PATH=tmp/disa_builds/tgz" >> $GITHUB_ENV
            echo "NIC_FW_PATH=tmp/corenic_builds/tgz" >> $GITHUB_ENV
          fi
        env:
          RELEASE: ${{ inputs.fw_release_type }}

      - name: Extract tags name from branch
        if: github.event_name == 'push'
        shell: bash
        run: |
          HEAD_REF="${{ github.head_ref || github.ref_name }}"
          TAGS=${HEAD_REF%${{ env.JIRA_TICKET }}*}
          TAGS=${TAGS#test}
          echo "TAGS=$TAGS" >> $GITHUB_ENV

      - name: Populate test matrix on push
        if: github.event_name == 'push'
        id: matrix_push
        shell: python3 {0}
        run: |
          import json
          import os as operating_sys

          testMatrix = {'platform':[
                          'osprey'],
                        'os':[
                          'ci-CentOS-8'],
                        'kernel':[
                          '${{ env.KERNEL_TAR }}']
                        }
          tags = '${{ env.TAGS }}'
          names = []
          include = []

          if 'reboot' in tags:
            names.append('reboot_tests')
            include.append({'name':'reboot_tests',
                            'iproute_version':'5.15.0',
                            'firmware_name':'agilio-nic-firmware-',
                            'firmware_path':'binaries/nic/releases/tgz',
                            'config_file':'generic',
                            'test_cases':'reboot&'})

          if 'reload' in tags:
            names.append('reload_tests')
            include.append({'name':'reload_tests',
                            'iproute_version':'5.15.0',
                            'firmware_name':'agilio-nic-firmware-',
                            'firmware_path':'binaries/nic/releases/tgz',
                            'config_file':'generic',
                            'test_cases':'reload&'})

          if 'unit' in tags:
            names.append('unit_tests')
            include.append({'name':'unit_tests',
                            'iproute_version':'5.15.0',
                            'firmware_name':'agilio-sriov-firmware-',
                            'firmware_path':'binaries/nic/releases/tgz',
                            'config_file':'generic',
                            'test_cases':'unit.(multi|sriov).*&'})

          if 'netdev' in tags:
            names.append('netdev_bpf_tests')
            include.append({'name':'netdev_nic_tests',
                            'iproute_version':'5.15.0',
                            'firmware_name':'agilio-nic-firmware-',
                            'firmware_path':'binaries/nic/releases/tgz',
                            'config_file':'generic',
                            'test_cases':'netdev.bpf.*&'})

            names.append('netdev_flower_tests')
            include.append({'name':'netdev_flower_tests',
                            'iproute_version':'5.15.0',
                            'firmware_name':'agilio-flower-app-firmware-',
                            'firmware_path':'binaries/disa/releases/tgz',
                            'config_file':'flower',
                            'test_cases':'netdev.flower.*&'})

            names.append('netdev_sriov_tests')
            include.append({'name':'netdev_sriov_tests',
                            'iproute_version':'5.15.0',
                            'firmware_name':'agilio-sriov-firmware-',
                            'firmware_path':'binaries/nic/releases/tgz',
                            'config_file':'generic',
                            'test_cases':'netdev.(multi|sriov).*&'})

          if 'flower' in tags:
            names.append('flower_tests')
            include.append({'name':'flower_tests',
                            'iproute_version':'5.15.0',
                            'firmware_name':'agilio-flower-app-firmware-',
                            'firmware_path':'binaries/disa/releases/tgz',
                            'config_file':'flower',
                            'test_cases':'flower&'})

          if tags == '-':
            names.append('flower_tests')
            include.append({'name':'flower_tests',
                            'iproute_version':'5.15.0',
                            'firmware_name':'agilio-flower-app-firmware-',
                            'firmware_path':'binaries/disa/releases/tgz',
                            'config_file':'flower',
                            'test_cases':'flower&'\
                                        'netdev.flower.*&'})

            names.append('sriov_tests')
            include.append({'name':'sriov_tests',
                            'iproute_version':'5.15.0',
                            'firmware_name':'agilio-sriov-firmware-',
                            'firmware_path':'binaries/nic/releases/tgz',
                            'config_file':'generic',
                            'test_cases':'reload&'\
                                        'reboot&'\
                                        'netdev.(multi|sriov|nic).*&'\
                                        'unit.(multi|sriov|nic).*&'})

          testMatrix["name"] = names
          testMatrix["include"] = include
          with open(operating_sys.environ['GITHUB_OUTPUT'], 'a') as github_output:
            github_output.write(f"matrix={testMatrix}")

      - name: Populate test matrix on dispatch
        if: github.event_name == 'workflow_dispatch'
        id: matrix_dispatch
        shell: python3 {0}
        run: |
          import json
          import os as operating_sys

          testMatrix = {'kernel':[
                          '${{ env.KERNEL_TAR }}']
                        }
          os = []
          platform = []
          names = []
          include = []

          if ( '${{ inputs.os }}' == 'all' ):
            os.append('ci-CentOS-8')
            os.append('ci-Ubuntu-20.04')
          elif ( '${{ inputs.os }}' == 'any' ):
            os.append('ci-cluster')
          else:
            os.append('ci-${{ inputs.os }}')

          if ( '${{ inputs.platform }}' == 'all' ):
            platform.append('osprey')
            platform.append('kestrel')
          else:
            platform.append('${{ inputs.platform }}')

          search_key = '${{ env.SEARCH_KEY }}'
          fw_path = '${{ env.BPF_FW_PATH }}'

          if ( '${{ inputs.test }}' == 'all' and
              ( '${{ inputs.fw_type }}' == 'BPF:agilio-bpf-firmware' ) ):

            if ( search_key == '' ):
              search_key = 'agilio-bpf-firmware-.*${{ inputs.fw_version }}.*'

            names.append('BPF_tests')
            include.append({'name':'BPF_tests',
                            'iproute_version':'5.12.0',
                            'firmware_name':search_key,
                            'firmware_path':fw_path,
                            'config_file':'generic',
                            'test_cases':'ebpf&'\
                                        'ebpfdrv&'\
                                        'ebpf_perf&'\
                                        'ebpf_perf_drv&'\
                                        'netdev.bpf.*&'})

          search_key = '${{ env.SEARCH_KEY }}'
          fw_path = '${{ env.DISA_FW_PATH }}'

          if ( '${{ inputs.test }}' == 'all' and
              ( '${{ inputs.fw_type }}' == 'AUTO:all' or
              '${{ inputs.fw_type }}' == 'DISA:agilio-flower-app-firmware' ) ):

            if ( search_key == '' ):
              search_key = 'agilio-flower-app-firmware-.*${{ inputs.fw_version }}.*'

            names.append('DISA_tests')
            include.append({'name':'DISA_tests',
                            'iproute_version':'5.15.0',
                            'firmware_name':search_key,
                            'firmware_path':fw_path,
                            'config_file':'flower',
                            'test_cases':'flower&'\
                                         'netdev.flower.*&'})

          search_key = '${{ env.SEARCH_KEY }}'
          fw_path = '${{ env.NIC_FW_PATH }}'

          if ( '${{ inputs.test }}' == 'all' and
              '${{ inputs.fw_type }}' == 'NIC:agilio-nic-firmware' ):

            if ( search_key == '' ):
              search_key = 'agilio-nic-firmware-.*${{ inputs.fw_version }}.*'

            names.append('CoreNIC_tests')
            include.append({'name':'CoreNIC_tests',
                            'iproute_version':'5.15.0',
                            'firmware_name':search_key,
                            'firmware_path':fw_path,
                            'config_file':'generic',
                            'test_cases':'reload&'\
                                        'reboot&'\
                                        'netdev.(multi|nic).*&'\
                                        'unit.(multi|nic).*&'})

          search_key = '${{ env.SEARCH_KEY }}'
          fw_path = '${{ env.NIC_FW_PATH }}'

          if ( '${{ inputs.test }}' == 'all' and
              ( '${{ inputs.fw_type }}' == 'AUTO:all' or
              '${{ inputs.fw_type }}' == 'SRIOV:agilio-sriov-firmware') ):

            if ( search_key == '' ):
              search_key = 'agilio-sriov-firmware-.*${{ inputs.fw_version }}.*'

            names.append('SRIOV_tests')
            include.append({'name':'SRIOV_tests',
                            'iproute_version':'5.15.0',
                            'firmware_name':search_key,
                            'firmware_path':fw_path,
                            'config_file':'generic',
                            'test_cases':'reload&'\
                                        'reboot&'\
                                        'netdev.(multi|sriov).*&'\
                                        'unit.(multi|sriov).*&'})

          search_key = '${{ env.SEARCH_KEY }}'

          if ( '${{ inputs.test }}' != 'all' ):
            if ( 'BPF' in '${{ inputs.fw_type}}' ):
              fw_path = '${{ env.BPF_FW_PATH }}'
              iproute = '5.12.0'
              config = 'generic'
            elif ( 'DISA' in '${{ inputs.fw_type}}' ):
              fw_path = '${{ env.DISA_FW_PATH }}'
              iproute = '5.15.0'
              config = 'flower'
            else:
              fw_path = '${{ env.NIC_FW_PATH }}'
              iproute = '5.15.0'
              config = 'generic'

            names.append('user_specified_tests')
            include.append({'name':'user_specified_tests',
              'iproute_version':iproute,
              'firmware_name':search_key,
              'firmware_path':fw_path,
              'config_file':config,
              'test_cases':'${{ inputs.test }}&'})

          testMatrix["os"] = os
          testMatrix["platform"] = platform
          testMatrix["name"] = names
          testMatrix["include"] = include
          with open(operating_sys.environ['GITHUB_OUTPUT'], 'a') as github_output:
            github_output.write(f"matrix={testMatrix}")

      - name: Print test matrix
        id: matrix
        shell: python3 {0}
        run: |
          import json
          import os as operating_sys

          if '${{ github.event_name }}' == 'push':
            with open(operating_sys.environ['GITHUB_OUTPUT'], 'a') as github_output:
              github_output.write(f"matrix={str(${{ steps.matrix_push.outputs.matrix }})}")

          if '${{ github.event_name }}' == 'workflow_dispatch':
            with open(operating_sys.environ['GITHUB_OUTPUT'], 'a') as github_output:
              github_output.write(f"matrix={str(${{ steps.matrix_dispatch.outputs.matrix }})}")

  regression-tests:
    name: '${{ matrix.name }} - ${{ matrix.os }}/${{ matrix.platform }}'
    needs: prepare
    strategy:
      fail-fast: false
      matrix: ${{ fromJSON(needs.prepare.outputs.matrix) }}
    runs-on:
      - self-hosted
      - ${{ matrix.platform }}
      - ${{ matrix.os }}
      - ci-cluster-vm
      - DUT-DUT
      - two-port
    steps:
    # ----- PROVISION -----
      - name: Clean old artifacts
        run: sudo git clean -ffdx || sudo find -delete

      - name: Checkout provisioning repo
        uses: actions/checkout@v3
        with:
          repository: Corigine/ci-libs
          ref: main
          token: ${{ secrets.GHUB_TOKEN }}
          path: ci-libs

      - name: Source environment variables
        shell: bash
        run: |
          source ci-libs/ci-config/$HOSTNAME/environment
          echo "DUT=$CLUSTER_DUT" >> $GITHUB_ENV

      - name: Get kernel to revert to after tests
        if: always()
        id: KERNEL_RESET
        uses: ./ci-libs/github_actions/utilities/remote_command
        with:
          host: ${{ env.DUT }}
          cmd: uname -r

      - name: Create directory for custom kernel and llvm tarballs
        shell: bash
        run: |
          mkdir ci-libs/ansible/roles/kernel_installer/files
          mkdir ci-libs/ansible/roles/llvm/files

      - name: Get DUT OS
        if: always()
        id: OS
        uses: ./ci-libs/github_actions/utilities/remote_command
        with:
          host: ${{ env.DUT }}
          cmd: |
            DISTRO=$(sed -n "s@^NAME=\"\(.*\)\"@\1@p" /etc/os-release)
            VERSION=$(sed -n "s@^VERSION_ID=\"\(.*\)\"@\1@p" /etc/os-release)
            echo ${DISTRO%% *}-$VERSION

      - name: Download kernel
        uses: ./ci-libs/github_actions/azure/azcopy_download_sync
        with:
          connection-string: ${{ secrets.AZ_SAS_TOK }}
          src: tmp/misc/kernels/${{ inputs.kernel_source }}_builds/${OS//\\n/}/${{ matrix.kernel }}
          dst: ci-libs/ansible/roles/kernel_installer/files/${{ matrix.kernel }}
        env:
          OS: ${{ steps.OS.outputs.stdout }}

      - name: Find llvm
        uses: ./ci-libs/github_actions/azure/azcopy_list
        id: artifact_llvm
        with:
          connection-string: ${{ secrets.AZ_SAS_TOK }}
          src: binaries/misc/llvm
          pattern: 'llvm-toolchain-13.*'

      - name: Download llvm
        uses: ./ci-libs/github_actions/azure/azcopy_download_sync
        with:
          connection-string: ${{ secrets.AZ_SAS_TOK }}
          src: binaries/misc/llvm/${{ steps.artifact_llvm.outputs.latest }}
          dst: ci-libs/ansible/roles/llvm/files/llvm-toolchain.tar.gz

      - name: Provision test machines
        uses: ./ci-libs/github_actions/ansible/ansible_playbook
        with:
          playbook: provision_ci_dev_drv.yaml
          tags: provision
          extra_vars: |
            target=${HOSTNAME//-/_}
            allow_unsupported_platforms=yes
            kernel_src='custom_package'
            kernel_file_tar=${{ matrix.kernel }}
            ci_dev_drv_iproute_version=${{ matrix.iproute_version }}
            ci_dev_drv_install=false
            ci_dev_drv_nfp_source_dir=/root/nfp-drv-kmods-private
            ci_dev_drv_nfp_source_dir_orch=${{ github.workspace }}
            drv_llvm_install_src='custom_package'
            ci_dev_drv_nti_version='main'
            nti_dir=${{ github.workspace }}/nti-private
            dut_drv_version=${{ github.head_ref || github.ref_name }}
            github_token=${{ secrets.GHUB_TOKEN }}
          sudo: yes

      - name: Get kernel to uninstall after tests
        if: always()
        id: KERNEL_REMOVE
        uses: ./ci-libs/github_actions/utilities/remote_command
        with:
          host: ${{ env.DUT }}
          cmd: uname -r

      - name: Reformat names for kernels for kernel_uninstaller
        if: always()
        shell: bash
        run: |
          KERNEL_RESET=${{ steps.KERNEL_RESET.outputs.stdout }}
          echo "KERNEL_RESET=${KERNEL_RESET//\\n/}" >> $GITHUB_ENV
          KERNEL_REMOVE=${{ steps.KERNEL_REMOVE.outputs.stdout }}
          echo "KERNEL_REMOVE=${KERNEL_REMOVE//\\n/}" >> $GITHUB_ENV

      - name: Create firmware directories for tests
        shell: bash
        run: |
          mkdir -p ./firmware/
          mkdir -p ./firmware/test/
          mkdir -p /tmp/logs/ci-dev-drv/

      - name: Find test FW
        uses: ./ci-libs/github_actions/azure/azcopy_list
        id: artifact_fw
        with:
          connection-string: ${{ secrets.AZ_SAS_TOK }}
          src: ${{ matrix.firmware_path }}
          pattern: ${{ matrix.firmware_name }}

      - name: Download test FW
        uses: ./ci-libs/github_actions/azure/azcopy_download_sync
        with:
          connection-string: ${{ secrets.AZ_SAS_TOK }}
          src: ${{ matrix.firmware_path }}/${{ steps.artifact_fw.outputs.latest }}
          dst: ./firmware/firmware.tar.gz

      - name: Extract test firmware
        shell: bash
        run: |
          sudo tar -xvzf ./firmware/firmware.tar.gz --strip-components=1 -C ./firmware/test/

      - name: Select correct card on DUT
        shell: bash
        working-directory: ${{ github.workspace }}/ci-libs/ci-config
        run: |
          cd $HOSTNAME
          for i in $(ls | grep AMDA || true); do
            PLATFORM_PRESENT=$(grep ${{ matrix.platform }} $i || true)
            if [[ $PLATFORM_PRESENT != '' ]]; then
              if [[ ${{ matrix.config_file }} = 'generic' ]]; then
                CONFIG_FILE=generic.$(echo $i | cut -d "-" -f2-).cfg
              else
                CONFIG_FILE=flower.$(echo $i | cut -d "-" -f2).cfg
              fi
              echo "CONFIG_FILE=$CONFIG_FILE" >> $GITHUB_ENV
              break
            fi
          done

      - name: Add copied driver to git safe directory list
        run: |
          cd nfp-drv-kmods-private
          git config --global --add safe.directory `pwd`

      - name: Run tests
        id: tests
        shell: bash
        working-directory: ${{ github.workspace }}/nfp-drv-kmods-private
        run: |
          OS=${OS//\\n/}
          OS=${OS//\'/}
          if [[ '${{ matrix.name }}' = 'user_specified_tests' ]]; then
            TESTNAME=$(echo ${TESTS//&/_} | sed 's/\.\*//g')
          else
            TESTNAME=${{ matrix.name }}_
          fi
          HASH=$(git rev-parse --short=10 HEAD)
          RUN_NAME=$(date -u +%Y.%m.%d-%H.%M)_${TESTNAME}$OS.${{matrix.platform}}.${HASH:0:10}
          LOG_PATH=/tmp/logs/ci-dev-drv/$RUN_NAME
          FAIL=false

          for test in $(echo $TESTS | tr '&' ' '); do
            ../nti-private/ti/ticmd \
            -c ../ci-libs/ci-config/$HOSTNAME/ci-dev-drv/${{ env.CONFIG_FILE }} \
            -l $LOG_PATH/$test run tests.$test | \
            sed --unbuffered 's/.*FAILED/\0\n::error::\0/' || FAIL=true
          done

          cd $LOG_PATH/../
          tar -zcf $RUN_NAME.tgz $RUN_NAME
          echo "LOG_PATH=$LOG_PATH" >> $GITHUB_ENV

          if [ ! "$DEFAULT_BRANCH" = "main" ]; then
            DST_SUFFIX=".${DEFAULT_BRANCH#wip-}"
          fi
          case "$GITHUB_REF" in
            "refs/heads/release-"*)
              OUT_PATH="binaries/nfp-drv-dkms/releases$DST_SUFFIX"
              ;;
            "refs/heads/prerelease-"*)
              OUT_PATH="binaries/nfp-drv-dkms/prereleases$DST_SUFFIX"
              ;;
            "refs/heads/${DEFAULT_BRANCH}")
              OUT_PATH="binaries/nfp-drv-dkms/interim$DST_SUFFIX"
              ;;
            *)
              OUT_PATH="tmp/nfp_drv_dkms_builds$DST_SUFFIX"
              ;;
          esac
          echo "OUT_PATH=$OUT_PATH" >> $GITHUB_ENV

          if ${FAIL}; then
            exit 1
          fi
        env:
          OS: ${{ steps.OS.outputs.stdout }}
          TESTS: ${{ matrix.test_cases }}
          DEFAULT_BRANCH: ${{ inputs.default_branch }}

      - name: Upload test logs to Azure
        if: >-
          success() && steps.tests.conclusion == 'success' ||
          failure() && steps.tests.conclusion == 'failure'
        uses: ./ci-libs/github_actions/azure/azcopy_upload_sync
        with:
          connection-string: ${{ secrets.AZ_SAS_TOK }}
          src: ${{ env.LOG_PATH }}.tgz
          dst: ${{ env.OUT_PATH }}/test_logs/ci-test-dev


      - name: Uninstall kernel from test machines
        if: always() && ( env.KERNEL_RESET != env.KERNEL_REMOVE )
        uses: ./ci-libs/github_actions/ansible/ansible_playbook
        with:
          playbook: site.yaml
          tags: kernel_uninstaller
          extra_vars: |
            target=${HOSTNAME//-/_}_dut
            allow_unsupported_platforms=yes
            kernel_remove=${KERNEL_REMOVE//-/_}
            kernel_uninstaller_ver_reset=${{ env.KERNEL_RESET }}
            github_token=${{ secrets.GHUB_TOKEN }}
          sudo: yes
